{"pages":[{"title":"about","text":"Hello :)","link":"/about/index.html"}],"posts":[{"title":"[공공데이터 분석] 코로나 감염 현황 분석 - 데이터 수집","text":"코로나 감염 현황 정보를 받아오기 위해 Python을 이용하여 데이터를 수집 합니다. 만약 인증키가 없는 경우 인증키 발급이 필요합니다. Google Colaboratory본 과정은 Google Colaboratory 환경을 이용합니다. Google Colaboratory(이하, Colab)은 브라우저에서 Python Code를 작성하고 실행할 수 있는 개발 환경입니다. Colab은 무료로 CPU/GPU/TPU 환경을 사용 할 수 있으며 코드 공유가 쉽다는 장점을 가지고 있습니다. 브라우저에서 Google Colaboratory을 검색하거나 주소창에 https://colab.research.google.com 를 입력합니다. 하단의 새 노트를 클릭하면 Jupyter Notebook 환경과 유사한 Python Code를 작성하고 실행할 수 있는 개발 환경을 확인 할 수 있습니다. 좌측 상단의 제목인 Untitled0.ipynb을 클릭하면 파일명을 변경 할 수 있습니다. 데이터 수집모듈 설치데이터 수집을 위해선 서버에 데이터 요청을 해야합니다. Python 환경에서 HTTP Requests를 하기 위해 Requests 모듈과 XML 형식의 응답 결과를 JSON 구조로 만들기 위한 xmltodict 모듈과 데이터프레임을 생성하고 데이터 가공에 특화된 Pandas 모듈을 설치합니다. 1pip install requests xmltodict pandas 만약, Colab 환경을 사용하는 경우 xmltodict 모듈만 설치하면 됩니다. 필요 모듈 설치가 완료되면 아래의 코드를 실행하여 설치한 모듈을 import합니다. 12345# 필요한 모듈을 import 합니다.import json # Python에서 JSON을 사용하기 위한 모듈import requests # HTTP Requests를 위한 모듈import xmltodict # XML 형식을 JSON으로 변환하기 위한 모듈import pandas as pd # DataFrame을 생성하고 가공하기 위한 모듈 URL 작성HTTP Requests를 위해서는 URL을 작성해야합니다. 보건복지부 코로나 19 감염 현황의 경우 기본 서비스 URL은 http://openapi.data.go.kr/openapi/service/rest/Covid19/getCovid19InfStateJson 이며 서비스키(ServiceKey)를 필수로 포함해야합니다. 이외 필요 정보는 다음과 같습니다. 요청 변수(Request Parameter) 항목명(국문) 항목명(영문) 항목크기 항목구분 샘플데이터 항목설명 서비스키 ServiceKey 4 필수 - 공공데이터포털에서 받은 인증키 페이지 번호 pageNo 4 옵션 1 페이지번호 한 페이지 결과 수 numOfRows 4 옵션 10 한 페이지 결과 수 데이터 생성일 시작범위 startCreateDt 30 옵션 20200310 검색할 생성일 범위의 시작 데이터 생성일 종료범위 endCreateDt 30 옵션 20200315 검색할 생성일 범위의 종료 응답 결과(Response Element) 항목명(국문) 항목명(영문) 항목크기 항목구분 샘플데이터 항목설명 결과코드 resultCode 2 필수 00 결과코드 결과메시지 resultMsg 50 필수 OK 결과메시지 한 페이지 결과 수 numOfRows 4 필수 10 한 페이지 결과 수 페이지 번호 pageNo 4 필수 1 페이지번호 전체 결과 수 totalCount 4 필수 3 전체 결과 수 게시글번호(감염현황 고유값) SEQ 30 필수 74 게시글번호(감염현황 고유값) 기준일 STATE_DT 30 필수 20200315 기준일 기준시간 STATE_TIME 30 필수 00:00 기준시간 확진자 수 DECIDE_CNT 15 필수 8162 확진자 수 격리해제 수 CLEAR_CNT 15 필수 834 격리해제 수 검사진행 수 EXAM_CNT 15 필수 16272 검사진행 수 사망자 수 DEATH_CNT 15 필수 75 사망자 수 치료중 환자 수 CARE_CNT 15 필수 7253 치료중 환자 수 결과 음성 수 RESUTL_NEG_CNT 15 필수 243778 결과 음성 수 누적 검사 수 ACC_EXAM_CNT 15 필수 268212 누적 검사 수 누적 검사 완료 수 ACC_EXAM_COMP_CNT 15 필수 251940 누적 검사 완료 수 누적 환진률 ACC_DEF_RATE 30 필수 3.2396602365 누적 환진률 등록일시분초 CREATE_DT 30 필수 2020-03-15 10:01:22.000 등록일시분초 수정일시분초 UPDATE_DT 30 필수 null 수정일시분초 따라서, http://openapi.data.go.kr/openapi/service/rest/Covid19/getCovid19InfStateJson?ServiceKey=발급받은서비스키와 같이 접속하면 데이터를 요청 할 수 있습니다. 데이터 요청발급 받은 인증키를 API_KEY 부분에 입력 후 코드를 실행하면 정상적으로 데이터를 받아온 경우 &lt;Response [200]&gt;와 같은 결과가 나옵니다. 만약 200이 아닌 경우 요청 및 응답을 받아오는 과정에서 에러가 발생한 경우이며 [] 안에 있는 숫자가 에러 코드를 의미합니다. 12345678910# Requests를 위한 URL을 생성합니다.# Requests를 위한 URL을 생성합니다.url = 'http://openapi.data.go.kr/openapi/service/rest/Covid19/getCovid19InfStateJson?'url += 'serviceKey=API_KEY'url += '&amp;startCreateDt=20200101'url += '&amp;endCreateDt=20201231'res = requests.get(url)res 응답 데이터를 보기 위해서는 응답 변수의 text 속성을 조회하면 확인 할 수 있습니다. 12# 응답 결과의 내용을 조회합니다.res.text 응답 데이터 변환응답 결과는 XML 형식으로 데이터가 기록되어 있고 원하는 데이터를 추출하기에 조금 어려움이 있습니다. 이를 쉽게 접근하기 위해 dict 형식으로 변환합니다. 12345678# 응답 결과의 내용을 Python Dict 형태로 변환합니다.res_json = xmltodict.parse(res.text) # 문자열을 XML을 JSON 형식으로 변환합니다.res_dict = json.dumps(res_json) # 변환된 JSON 형식을 Dictionary 문자열로 변환합니다.data = json.loads(res_dict) # Dictionary 문자열을 파이썬의 Dictionary 형식으로 변환합니다.data = json.loads(json.dumps(xmltodict.parse(res.text))) # 1줄로 작성된 변환 과정 사전 접근법을 이용하여 필요한 데이터에 접근합니다. 12# 필요한 데이터만 선택합니다.data['response']['body']['items'] 선택된 데이터만 데이터 프레임 형태로 변환합니다. 123# 선택된 데이터를 데이터 프레임으로 변환합니다.df = pd.DataFrame(data['response']['body']['items']['item'])df 변환된 파일을 파일로 저장합니다. 결과 저장12# seq 컬럼의 값을 기준으로 데이터 프레임을 오름차순 정렬 후 파일로 저장합니다.df.sort_values('seq').to_excel('코로나 19 감염 현황.xlsx', index=False) Colab 환경의 경우 좌측에 있는 폴더 모양 아이콘을 클릭하여 파일로 저장된 코로나 19 감염 현황 데이터를 다운로드 받습니다. 다운로드 받은 파일을 열어보면 다음과 같은 결과를 확인 할 수 있습니다. 본 과정에서 사용한 코드는 아래의 링크를 클릭하면 확인 할 수 있습니다. [공공데이터 분석] 코로나 감염 현황 분석 - 데이터 수집","link":"/2021/01/01/DATA-COVID-19-02/"},{"title":"[공공데이터 분석] 코로나 감염 현황 분석 - 데이터 가공","text":"오픈API를 이용해서 받아온 코로나 감염 현황 정보를 데이터를 가공합니다. 만약 데이터가 없는 경우 데이터 수집이 필요합니다.데이터만 필요한 경우 다운로드를 클릭하여 데이터를 다운로드 받을 수 있습니다. 데이터 업로드Google Colab 환경에서 외부 데이터를 읽어오는 방법은 업로드 하는 방법과 구글 드라이브를 마운트해서 읽어오는 방법이 있습니다. 본 글에서는 직접 업로드를 통해 외부 데이터를 Colab 환경에 추가합니다. 이를 위해 좌측의 폴더 모양 아이콘을 클릭합니다. 만약 세션에 연결되어있지 않다면 자동으로 세션을 연결 합니다. 이후 좌측의 업로드 아이콘을 클릭하여 업로드 하고자 하는 파일을 선택합니다. 업로드가 완료되면 데이터를 읽어 옵니다. 만약 에러가 발생하는 경우 파일을 선택 후 우클릭을 통해 파일 이름을 변경하고 다시 데이터를 읽으면 정상적으로 읽어옵니다. 데이터 읽어오기앞서 데이터 수집 과정 저장한 코로나 19 감염 현황.xlsx을 Pandas 모듈을 이용하여 DataFrame으로 불러옵니다. 1234import pandas as pddf = pd.read_excel('코로나 19 감염 현황.xlsx')df 컬럼명 정리현재 영어로 설정된 컬럼명을 한글로 지정하기 위해 참고 문서를 다운로드 받거나 오픈API 상세 페이지 출력결과(Response Element)를 참고하여 다음과 같이 컬럼명을 변경합니다. 컬럼명을 변경하는 방법은 columns 속성을 이용하는 방법과 rename 함수를 이용하는 방법이 있습니다. 컬럼명 전체를 바꾸고자 하는 경우에는 columns 속성을 특정 대상의 컬럼명만 바꾸고자 하는 경우에는 rename 함수를 추천합니다. columns 속성을 이용한 컬럼명 변경 (전체 변경)1234df.columns = ['누적 환진률', '누적 검사 수', '누적 검사 완료 수', '치료중 환자 수', '격리해제 수', '등록일시분초', '사망자 수', '확진자 수', '검사진행 수', '결과 음성 수', '게시글번호', '기준일', '기준시간', '수정일시분초']df rename 함수를 이용한 컬럼명 변경 (특정 대상 변경)123456789101112131415df.rename(columns={'accDefRate': '누적 환진률', 'accExamCnt': '누적 검사 수', 'accExamCompCnt': '누적 검사 완료 수', 'careCnt': '치료중 환자 수', 'clearCnt': '격리해제 수', 'createDt': '등록일시분초', 'deathCnt': '사망자 수', 'decideCnt': '확진자 수', 'examCnt': '검사진행 수', 'resutlNegCnt': '결과 음성 수', 'seq': '게시글번호', 'stateDt': '기준일', 'stateTime': '기준시간', 'updateDt': '수정일시분초'}, inplace=True)df 결측치 처리COVID-19 초기에는 누적 환진률, 누적 검사 수와 같은 데이터가 존재하지 않기 때문에 값이 NaN으로 저장되어 있습니다. NaN이 있는 경우 데이터 연산이 정상적으로 이뤄지지 않을 수 있습니다. 이를 위해 NaN의 값을 전부 0으로 변경합니다. 12df.fillna(0, inplace=True)df 데이터 재정렬데이터 수집 과정에서 ‘게시글번호’(‘seq’)를 기준 컬럼으로 데이터를 정렬 했습니다. 정렬 결과를 보면 1, 2, 3 순서가 아닌 1, 10, 100으로 정렬된것을 확인할 수 있습니다. 이는 데이터를 수집하고 저장하는 과정에서 해당 컬럼의 데이터 타입이 문자열이기 때문에 발생한 문제입니다. 데이터를 재 정렬 합니다. 12df.sort_values('게시글번호', inplace=True)df 불필요한 컬럼 제거등록일시분초, 수정일시분초, 기준시간, 게시글번호 컬럼은 데이터 분석 과정에서 불필요한 컬럼으로 제거 합니다. 제거 하는 방법은 drop 함수를 이용하거나 등록일시분초과 수정일시분초 컬럼을 제외한 나머지 컬럼을 선택하는 형태로 사용 할 수 있습니다. 12df.drop(['등록일시분초', '수정일시분초', '기준시간', '게시글번호'], axis=1, inplace=True)df 데이터 형 변환현재 날짜를 담당하는 기준일 컬럼은 숫자형으로 인식되었습니다. 주차별, 월별과 같은 정보를 추출하기 위해선 datetime 형식으로 변환이 필요합니다. Pandas의 to_datetime함수를 이용하여 날짜형으로 변환합니다. format 형식을 지정하는 경우 변환 속도가 빨라진다는 장점이 있습니다. 12df['기준일'] = pd.to_datetime(df['기준일'], format=&quot;%Y%m%d&quot;)df 중복 데이터 제거코로나19 감염 현황의 경우 추가적인 역학조사 결과 등에 따라 수정 및 보완될 수 있습니다. 만약 동일 날짜에 여러 데이터가 존재한다면 차후 신규 확진자 수 계산시 잘못 계산 될 수 있기 때문에 중복 데이터가 있는지 value_counts 함수를 통해 확인합니다. 1df['기준일'].value_counts() 2020-02-08 (5건), 2020-04-25, 2020-02-21, 2020-02-18 (3건) 등 과 같이 동일 날짜에 여러 데이터가 존재하는것을 확인 할 수 있습니다. 중복데이터의 값을 확인하고 싶은 경우 loc 인덱서를 통해서 해당 날짜의 데이터만 조회 할 수 있습니다. 1df.loc[df['기준일'] == '2020-02-08', :] 중복 값을 제거하고 가장 마지막에 수정된 값만 남기기 위해 drop_duplicates 함수를 이용합니다. 12df.drop_duplicates('기준일', keep='last', inplace=True)df 데이터 프레임 정리현재 컬럼은 데이터 수집 과정에서 추출된 태그명의 알파벳 순서대로 정렬되어 있습니다. 이를 보기 편하게 재설정하며 인덱스도 초기화 합니다. 123df = df[['기준일', '검사진행 수', '결과 음성 수', '확진자 수', '사망자 수', '격리해제 수', '치료중 환자 수', '누적 검사 수', '누적 검사 완료 수', '누적 환진률']].reset_index(drop=True)df 전일 대비 계산현재 확진자 수, 사망자 수와 같은 정보는 해당 날짜 기준 누적 데이터 입니다. 따라서 전일 대비를 계산하여 증감값을 조회합니다. 123new_columns = ['전일대비 ' + name for name in df.columns[3:7]]df.loc[:, new_columns] = df.iloc[:, 3:7].diff().valuesdf 날짜 정보 추출특정 날짜 정보에 따른 변화를 확인 하기 위해 datetime 형식으로 변환된 기준일 컬럼을 대상으로 datetimelike properties을 이용하여 주차별, 월별, 요일별과 같은 날짜 정보를 추출합니다. 123456df['기준일_연도'] = df['기준일'].dt.yeardf['기준일_월'] = df['기준일'].dt.monthdf['기준일_요일'] = df['기준일'].dt.day_name()df['기준일_월'] = df['기준일'].dt.weekdf['기준일_분기'] = df['기준일'].dt.quarterdf 데이터 저장최종 가공 완료된 데이터를 저장합니다. 1df.to_excel('코로나 19 감염 현황 가공 완료.xlsx') Colab 환경의 경우 좌측에 있는 폴더 모양 아이콘을 클릭하여 파일로 저장된 코로나 19 감염 현황 데이터를 다운로드 받습니다. 다운로드 받은 파일을 열어보면 다음과 같은 결과를 확인 할 수 있습니다. 본 과정에서 사용한 코드는 아래의 링크를 클릭하면 확인 할 수 있습니다. [공공데이터 분석] 코로나 감염 현황 분석 - 데이터 가공","link":"/2021/01/04/DATA-COVID-19-03/"},{"title":"[공공데이터 분석] 코로나 감염 현황 분석 - 인증키 발급","text":"보건복지부에서는코로나19 감염_현황를 신속 투명하게 공개하기 위해 오픈 API를 기반으로 발생 상황에 대한 정보를 제공하고 있습니다. 해당 오픈 API를 사용하기 위해서는 공공데이터 포털에서 인증키를 발급받아야 합니다. 인증키를 발급받기 위해서는 공공데이터 포털의 계정이 필요하므로 보유하고 있는 계정이 없는 경우 회원가입을 먼저 진행합니다. API 인증키 발급공공데이터 포털에서 로그인을 한 후 코로나 19 감염 현황을 검색하면 관련된 데이터의 목록이 조회가 됩니다. 스크롤을 아래로 내려 오픈 API 항목에 있는 보건복지부_코로나19 감염_현황을 클릭합니다. 상세 화면에서 활용 신청 버튼을 클릭합니다. 신청에 필요한 정보를 기재합니다. 발급받은 인증키의 경우 정상적으로 인증이 되기까지 최대 2시간의 시간이 필요할 수 있습니다. 또한 발급된 인증키의 경우 외부에 유출되지 않도록 관리가 필요합니다. 활용신청 상세 기능정보에서 제공하는 미리 보기 기능을 통해 다음과 같이 필요한 요청 변수와 해당 요청의 결과를 조회할 수 있습니다. 만약 SERVICE_KEY_IS_NOT_REGISTERED_ERROR와 같은 결과가 나오는 경우 최대 2시간의 시간이 필요할 수 있습니다.","link":"/2020/12/31/DATA-COVID-19-01/"},{"title":"[PANDAS] Series &amp; DataFrame Basic","text":"Pandas는 Python 프로그래밍 언어를 기반으로 구축된 빠르고 강력하며 유연하고 사용하기 쉬운 오픈 소스 데이터 분석 및 조작 도구입니다. Pandas에서는 Series와 DataFrame 객체를 이용하여 데이터를 분석 및 조작할 수 있습니다. 본 글에서는 Series와 DataFrame에 대한 기본 사용 방법에 대해 알아봅니다. 데이터 접근 방법파이썬에서는 기본적으로 이름 뒤에 []가 온다면 데이터를 선택한다는 의미를 가지고 있습니다. 이러한 형식은 Python str, list, tuple, dict Numpy Array와 같은 데이터 형식에서도 동일한 의미를 가집니다. 데이터를 선택하는 과정을 인덱싱(Indexing)이라고 하며 만약 가지고 올 값이 여러 개인 경우 슬라이싱(Slicing)을 이용할 수 있습니다. Sequence 자료형의 경우 위치(숫자)를 dict 자료형의 경우 이름(문자열)을 이용합니다. SeriesSeries의 경우 Python list, tuple, Numpy Array에서 사용하는것과 동일하게 대괄호([행 인덱스])를 통해 개별 데이터에 접근할 수 있습니다. 1234import pandas as pdseries = pd.Series([1, 2, 3, 4, 5])series[0], series[2], series[1:2] Series의 경우 문자열 인덱스를 가질 수 있기 때문에 이름(문자열)을 통해서도 개별 데이터에 접근할 수 있습니다. 123series = pd.Series([1, 2, 3], index=['a', 'b', 'c'])series['a'], series['a':'c'], series[2], series[-1] 이때 위치(숫자)도 사용 가능하며 Slicing의 경우 위치는 콜론 뒤에 데이터를 포함하지 않지만 문자열의 경우 포함한다는 점이 차이점입니다. DataFrameDataFrame도 동일하게 인덱싱을 이용할 수 있지만 차이점이 존재합니다. Numpy Array의 경우 [행 인덱스, 열 인덱스]로 2차원 배열에서 데이터를 선택 가능하지만 DataFrame에서는 해당 방법을 사용 시 에러가 발생할 수 있습니다. 물론 loc, iloc, iat, at과 같은 인덱서를 이용하면 Numpy Array와 동일(유사)하게 동작합니다. DataFrame은 대괄호를 2개를 사용하며 [열 인덱스][행 인덱스]를 통해 개별 값에 접근할 수 있습니다. DataFrame은 여러 개의 시리즈가 칼럼 명을 Key로 가지는 Dict 형식이라고 생각해볼 수 있습니다. 즉 첫 번째 대괄호를 사용하여 1개의 Series를 선택하고 선택된 Series를 기반으로 다시 행을 접근한다고 생각하면 됩니다. 1234dataframe = pd.DataFrame( [[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=['A','B','C'])dataframe['A'] 만약 여러 개 또는 특정 범위의 컬럼을 선택하기 위해서 인덱싱을 한다면 생각한 것과 다른 결과가 나오거나 아예 데이터가 나오지 않을 수 있습니다. 이러한 이유는 대괄호 안에 슬라이싱을 적용할 때는 행 인덱스를 사용하기 때문입니다. 즉, 아래의 결과가 아무런 결과도 나오지 않는 이유는 행 인덱스는 [0, 1, 2]인데 ‘A’부터 ‘C’까지 데이터를 선택하라고 했기 때문에 결과가 나오지 않는 것을 확인할 수 있습니다. 1234dataframe = pd.DataFrame( [[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=['A','B','C'])dataframe['A':'C'] 1234dataframe = pd.DataFrame( [[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=['A','B','C'])dataframe[:2] 이러한 문제로 인해서 Pandas에서 데이터를 선택하는 과정은 loc, iloc, at, iat과 같은 인덱서를 이용하는 것을 추천합니다. 인덱서 바로가기 공통 기본 속성Series와 DataFrame 모두 index, values, columns(DataFrame만 존재), dtypes, shape, T, loc, iloc, at, iat과 같은 속성이 존재합니다. valuesvalues 속성은 Series 또는 DataFrame의 값을 Numpy Array 형식으로 반환합니다. 12series = pd.Series([1, 2, 3, 4, 5])series.values indexindex 속성은 Series 또는 DataFrame의 행 인덱스를 반환합니다. 추후 특정한 행 데이터 또는 조건에 성립하는 행 데이터를 삭제하기 위해선 인덱스 정보가 필요한데 이때 index 속성을 이용합니다. 12series = pd.Series([1, 2, 3, 4, 5])series.index columnscolumns 속성은 DataFrame에서만 사용할 수 있으며 열 인덱스(컬럼명)을 반환합니다. 1234dataframe = pd.DataFrame( [[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=['A','B','C'])dataframe.columns 앞서 이야기 한 3가지(index, columns, values) 속성이 중요한 이유는 데이터를 조회하는 기능과 동시에 수정도 지원하기 때문입니다. 즉, 컬럼명을 변경하고 싶은 경우 columns 속성에 새로운 컬럼명 리스트(동일한 데이터 개수를 가진)를 대입하는 경우 컬럼명이 변경됩니다. index 도 동일하며 index의 경우 행 인덱스를 변경됩니다. 123456dataframe = pd.DataFrame( [[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=['A','B','C'])dataframe.columns = ['X1', 'X2', 'X3']dataframe.index = ['a', 'b', 'c']dataframe dtypes데이터 유형을 조회할 수 있는 속성으로 DataFrame의 경우 각 열 별 데이터 타입의 결과가 반환됩니다. series의 경우 dtype 속성으로도 조회 가능합니다. (데이터 프레임은 불가) 1234dataframe = pd.DataFrame( [[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=['A','B','C'])dataframe.dtypes shape데이터의 형태를 조회할 수 있는 속성으로 Series의 경우 행 데이터 수가, DataFrame의 경우 행, 열 데이터 수가 튜플 형식으로 출력됩니다. 1234dataframe = pd.DataFrame( [[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=['A','B','C'])dataframe.shape # (행의 수, 열의 수) TTranspose의 줄임말이며 행과 열이 변경된 결과를 반환합니다. 1234dataframe = pd.DataFrame( [[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=['A','B','C'])dataframe.T loc, iloc, at, iat데이터에 접근할때 사용하는 인덱서(Indexer)로 Numpy Array에서 사용한 Index과 Slicing을 동일하게 진행 할 수 있습니다. 해당 부분은 데이터를 선택하는 포스트에서 따로 언급하도록 하겠습니다.","link":"/2021/01/03/PANDAS-BASIC/"},{"title":"[PANDAS] Series &amp; DataFrame Indexer","text":"Pandas는 Python 프로그래밍 언어를 기반으로 구축된 빠르고 강력하며 유연하고 사용하기 쉬운 오픈 소스 데이터 분석 및 조작 도구입니다. Pandas에서는 Series와 DataFrame 객체를 이용하여 데이터를 분석 및 조작할 수 있습니다. 본 글에서는 Series와 DataFrame에서 데이터를 선택하는 방법에 대해 알아봅니다. 인덱서의 사용 이유Pandas의 Series와 DataFrame 모두 대괄호([인덱스])를 이용하여 데이터를 가지고 올 수 있습니다. 하지만 Series의 경우 Indexing과 Slicing 모두 행을 대상으로 데이터를 가지고 오지만 DataFrame의 경우 Indexing은 열, Slicing은 행을 대상으로 동작합니다. Numpy Array와 통일성 있게 데이터를 가지고 오기 위해서는 인덱서(Indexer)를 이용합니다. Pandas에는 loc, iloc, at, iat 인덱서가 존재합니다. loc 인덱서loc 인덱서는 labels 즉 이름(문자열)을 기반으로 데이터에 접근할 수 있는 인덱서입니다. loc 인덱서는 다음과 같이 사용합니다. 데이터프레임변수이름.loc[행 인덱스, 열 인덱스] loc 인덱서를 사용하는 경우 행 또는 열 인덱스에는 다음과 같은 형식만 올 수 있습니다. 행 또는 열 이름(문자열) 행 또는 열 이름(문자열)의 리스트 행 또는 열 이름(문자열)의 슬라이싱 마지막 인덱스를 포함 Boolean List, 1D Array, Series DataFrame 불가 행을 대상으로만 데이터를 선택하고자 하는 경우 열 인덱스는 생략할 수 있습니다. 데이터 프레임 생성12345import numpy as npimport pandas as pddf = pd.DataFrame(np.arange(9).reshape(3, 3), index=['A', 'B', 'C'], columns=['X1', 'X2', 'X3'])df 단일 선택문자열을 이용하여 단일 행에 접근할 수 있습니다. 단일 행 접근1df.loc['A'] 단일 열 접근1df.loc[:, 'A'] 범위 선택슬라이싱을 이용하여 순차적인 다중 행에 접근할 수 있습니다. 마지막 인덱스를 포함합니다. 범위 행 접근1df.loc['A':'C'] 범위 열 접근1df.loc[:, 'X1':'X3'] 다중 선택리스트 형태로 행 인덱스를 지정하여 비순차적인 다중 행에 접근할 수 있습니다. 다중 행 접근1df.loc[['A', 'C']] 다중 열 접근1df.loc[:, ['X1', 'X3']] 조건 선택Boolean Series를 이용하여 True 값을 가지는 Index만 선택할 수 있습니다. 행 인덱스를 가지는 Boolean Sereis 이용1df.loc[ df['A'] % 2 == 0 ] 행 인덱스를 가지는 Boolean Sereis 이용1df.loc[:, df.columns != 'X2'] 값 수정인덱서를 이용하여 특정 데이터에 접근한다는 의미는 데이터를 조회할 수 있지만 데이터를 수정할 수도 있습니다. 인덱서를 이용하여 데이터를 선택 후 값을 대입하면 데이터가 수정이 됩니다. 대입하는 값이 1개인 경우 선택된 위치에 모두 같은 값이 대입됩니다. 단일 값 대입12df.loc['C'] = -1df 대입하는 값이 선택된 데이터와 개수가 같은 경우 위치대로 대입됩니다. 단, 대입되는 값이 Sereis인 경우 인덱스 별로 대입됩니다. 다중 값 대입12df.loc['C'] = [1, 2, 3]df 다중 값 대입12df.loc[:, 'X3'] = pd.Series([10, 10, 10], index=['B', 'C', 'D'])df iloc 인덱서iloc 인덱서는 integer 즉 위치(숫자)를 기반으로 데이터에 접근할 수 있는 인덱서입니다. iloc 인덱서는 다음과 같이 사용합니다. 데이터프레임변수이름.iloc[행 인덱스, 열 인덱스] loc 인덱서를 사용하는 경우 행 또는 열 인덱스에는 다음과 같은 형식만 올 수 있습니다. 행 또는 열 위치(정수) 행 또는 열 위치(정수)의 리스트 행 또는 열 위치(정수)의 슬라이싱 마지막 인덱스를 미포함 Boolean List, 1D Array Sereis 불가 행을 대상으로만 데이터를 선택하고자 하는 경우 열 인덱스는 생략할 수 있습니다. 데이터 프레임 생성12345import numpy as npimport pandas as pddf = pd.DataFrame(np.arange(9).reshape(3, 3), index=['A', 'B', 'C'], columns=['X1', 'X2', 'X3'])df 단일 선택문자열을 이용하여 단일 행에 접근할 수 있습니다. 단일 행 접근1df.iloc[0] 단일 열 접근1df.iloc[:, -1] 범위 선택슬라이싱을 이용하여 순차적인 다중 행에 접근할 수 있습니다. 마지막 인덱스를 미포함합니다. 범위 행 접근1df.iloc[1:] 범위 열 접근1df.iloc[:, 1:] 다중 선택리스트 형태로 행 인덱스를 지정하여 비순차적인 다중 행에 접근할 수 있습니다. 다중 행 접근1df.iloc[[0, 2]] 다중 열 접근1df.iloc[[0, 2], [1, 2]] 조건 선택Boolean Series를 이용하여 True 값을 가지는 Index만 선택할 수 있습니다. 행 인덱스를 가지는 Boolean List 이용1df.iloc[[True, False, True]] 행 인덱스를 가지는 Boolean List 이용1df.iloc[:, [True, False, True]] 값 수정인덱서를 이용하여 특정 데이터에 접근한다는 의미는 데이터를 조회할 수 있지만 데이터를 수정할 수도 있습니다. 인덱서를 이용하여 데이터를 선택 후 값을 대입하면 데이터가 수정이 됩니다. 대입하는 값이 1개인 경우 선택된 위치에 모두 같은 값이 대입됩니다. 단일 값 대입12df.iloc[-1] = -1df 대입하는 값이 선택된 데이터와 형태가 같은 경우 위치대로 대입됩니다. 다중 값 대입1df.iloc[:2, :2] = [[1, 2], [3, 4]] 단, 대입되는 값이 Sereis인 경우 인덱스 별로 대입됩니다. 다중 값 대입12df.iloc[-1] = pd.Series([10, 10, 10], index=['X2', 'X3', 'X4'])df at, iat 인덱서at 인덱서는 loc 인덱서와 동일하게 이름(문자열)을 기반으로 동작하며 iat 인덱서 iloc 인덱서와 동일하기 위치(정수)를 기반으로 데이터에 접근할 수 인덱서입니다. loc, iloc 인덱서는 복수개의 데이터에 접근할 수 있지만 at, iat 인덱서는 1개의 데이터에 접근할 수 있다는 차이점이 존재합니다. 규모가 큰 데이터 프레임에서 at 또는 iat 인덱서를 사용하는 경우 loc 또는 iloc 인덱서를 사용하는 경우보다 빠르게 데이터를 접근할 수 있습니다. 데이터 생성12345import numpy as npimport pandas as pddf = pd.DataFrame(np.arange(9).reshape(3, 3), index=['A', 'B', 'C'], columns=['X1', 'X2', 'X3'])df 성능 비교loc 단일 값 접근 속도1%timeit df.loc['index100', 'columns100'] at 단일 값 접근 속도1%timeit df.at['index100', 'columns100'] iloc 단일 값 접근 속도1%timeit df.iloc[100, 100] iat 단일 값 접근 속도1%timeit df.iat[100, 100] 실습loc, iloc 인덱서를 이용하여 데이터를 선택하고 수정하는 작업은 데이터 분석 과정에서 필수적이다고 할 수 있습니다. 그중에서도 loc 인덱서의 사용법을 제대로 숙지하고 있다면 데이터 처리에 많은 이점이 있습니다. 아래의 링크를 클릭하여 loc 인덱서의 사용법과 학습 정도를 평가해볼 수 있습니다. 실습하러가기","link":"/2021/01/06/PANDAS-SELECTION/"},{"title":"[PANDAS] Series &amp; DataFrame Creation","text":"Pandas는 Python 프로그래밍 언어를 기반으로 구축된 빠르고 강력하며 유연하고 사용하기 쉬운 오픈 소스 데이터 분석 및 조작 도구입니다. Pandas에서는 Series와 DataFrame 객체를 이용하여 데이터를 분석 및 조작할 수 있습니다. 본 글에서는 Series와 DataFrame을 생성하는 방법에 대해 알아봅니다. 먼저 Pandas와 Numpy 모듈을 import 합니다. 12import numpy as npimport pandas as pd SeriesSeries는 모든 데이터 유형(int, float, str, object 등)을 저장할 수 있는 1차원 데이터 구조입니다. 1차원 Numpy Array와 동일하게 위치(정수)를 기반으로 Indexing과 Slicing을 사용할 수 있다는 점이 동일하지만 인덱스 문자로 지정한 경우 이름(문자열)을 기반으로 Indexing과 Slicing을 할 수 있습니다. Series는 1차원 자료 구조를 기반으로 Series 객체를 만들어 주는 생성자 함수를 이용하여 생성할 수 있습니다. a Python dict, list, tuple an ndarray a scalar value (like 5) 인덱스를 설정하지 않는 경우 기본적으로 위치(정수)가 옵니다. 기존에 사용하는 1차원 자료 구조와는 다르게 데이터가 열을 기준으로 나열됩니다. 123series = pd.Series([1, 2, 3, 4, 5])series 인덱스를 문자로 지정하고 싶은 경우 index 매개변수에 데이터와 동일한 개수를 가지는 1차원 자료 구조를 대입합니다. 123series = pd.Series([1, 2, 3, 4, 5], index=['A', 'B', 'C', 'D', 'E'])series DataFrameDataFrame은 Pandas에서 가장 많이 사용되는 구조로 2차원 데이터 구조로 행과 열이 존재하는 테이블 구조입니다. 많이 사용하는 엑셀의 한 Sheet 또는 SQL의 테이블이라고도 볼 수 있습니다. 또한 DataFrame은 여러개의 Series가 Dict로 묶여 있다고도 볼 수 있습니다. DataFrame은 2차원 자료 구조를 기반으로 DataFrame 객체를 만들어 주는 생성자 함수를 이용하여 생성할 수 있습니다. Dict of 1D ndarrays, lists, dicts, or Series 2-D numpy.ndarray Structured or record ndarray A Series Another DataFrame 행 인덱스와 열 인덱스(컬럼명)를 설정하지 않는 경우 기본적으로 위치(정수)가 옵니다. 1234dataframe = pd.DataFrame( [[1, 2, 3], [4, 5, 6], [7, 8, 9]])dataframe 행 인덱스를 문자로 지정하고 싶은 경우 index 매개 변수를 열 인덱스를 문자로 지정하고 싶은 경우 columns 매개 변수에 동일한 개수를 가지는 1차원 자료 구조를 대입합니다. 1234dataframe = pd.DataFrame( [[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=['A','B','C'])dataframe 1234dataframe = pd.DataFrame( [[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=['A','B','C'], index=['a', 'b', 'c'])dataframe 또한 DataFrame은 Dict를 기반으로도 생성할 수 있습니다. 이때 Dict의 키가 가지고 있는 Value의 개수는 동일해야 하며 Dict의 키가 열 인덱스(컬럼명)로 지정됩니다. 123456dataframe = pd.DataFrame( { 'A' : [1, 2, 3], 'B' : [4, 5, 6], 'C' : [7, 8, 9]})dataframe","link":"/2021/01/02/PANDAS-CREATE/"},{"title":"[환경설정] Apple Silicon 개발 환경 설정","text":"현재 사용 중인 M1 MacMini와 M1 MacBook Pro에서 다음과 같은 초기 작업을 진행합니다. Oh-My-Zsh 설정 Brew 설치 (Rosetta2 이용) Tensorflow 설치 Zsh 설정12345sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestionsgit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting .zshrc1plugins=(git zsh-autosuggestions zsh-syntax-highlighting) Brew 설치1arch -x86_64 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot; .zshrc1alias ibrew=&quot;arch -x86_64 brew&quot; Tensorflow 설치1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/apple/tensorflow_macos/master/scripts/download_and_install.sh)&quot; SpaceVim 설치1curl -sLf https://spacevim.org/install.sh | bash","link":"/2020/12/29/SETTING-APPLE-M1/"},{"title":"[TensorFlow] Certificate 준비 및 시험 과정","text":"Tensorflow CertificateTensorFlow Certificate은 딥러닝 및 머신러닝(ML) 문제를 해결할 수 있는 능력을 입증하기 위한 일종의 자격증입니다. 시험은 5시간 동안 진행되며 크게 DNN, CNN, RNN 모델 생성 및 튜닝에 대해 할 수 있으면 합격할 수 있는 난이도입니다. 시험 환경은 PyCharm IDE 기반으로 TensorFlow Exam 플러그인을 설치하여 시험이 진행되며 최신 버전인 2020.3에선 지원하지 않으니 꼭 2020.2 버전을 설치 해야 합니다. 2020년 12월 25일 기준 이외 자세한 사항은 TensorFlow 개발자 인증을 통해 확인 할 수 있습니다. 시험 준비 사항앞서 이야기 한 대로 시험은 총 5시간 동안 진행되며 5가지 유형(Category)의 모델을 구현하고 제출 하면 됩니다. 5가지 유형은 다음과 같습니다. (해당 내용은 개발자 인증 프로그램 핸드북에서 확인 할 수 있습니다.) Category 1: Basic / Simple model Category 2: Model from learning dataset Category 3: Convolutional Neural Network with real-world image dataset Category 4: NLP Text Classification with real-world text dataset Category 5: Sequence Model with real-world numeric dataset 시험의 경우 구글에서 친절히 관련 강의를 소개 하고 있습니다. DeepLearning.AI TensorFlow 개발자 전문 자격증 Intro to TensorFlow for Deep Learning 또한 이외 국내 강의는 다음과 같이 있습니다 텐서플로우 자격증 취득 (온라인) 만약, TensorFlow에 대해 처음 접하는 경우 텐서플로우 자격증 취득 (온라인)를 추천합니다. 시험 과정응시 전시험 응시 전 사전에 Google TensorFlow Developer Certificate에서 시험을 결제 합니다. 시험 응시료는 100$이며 신분증(여권, 면허증)과 본인 인증 사진(웹캠) 업로드 과정이 포함되어 있습니다. 신청 과정을 다 끝내면 접수한 내용을 검토하는 과정으로 인해 시간이 소모됩니다. 이로 인해 바로 시험을 진행 할 수 없으니 미리 결제를 한 후 시험 응시 전 Redeem을 활성화 하는 것을 추천합니다. 만약 과정이 다 끝나면 다음과 같이 정보를 확인 할 수 있으며 Redeem 이라는 버튼이 존재합니다. 해당 버튼을 누르면 시험이 응시되니 꼭 시험 볼 준비가 완료 된 이후 클릭 하시는걸 추천드립니다. 저의 경우 이미 응시한 시험 정보로 Redeem 버튼은 보이지 않는 상태입니다. 응시 환경 구축시험 환경은 PyCharm IDE 기반으로 TensorFlow Exam 플러그인을 설치하여 시험이 진행되며 최신 버전인 2020.3에선 지원하지 않으니 꼭 2020.2 버전을 설치 해야 합니다. PyCharm 2020.2 버전은 다운로드를 클릭하면 받을 수 있습니다. 또한 Anaconda Platform을 이용하는것을 추천합니다. 응시 후5가지 유형(Category)의 모델을 구현 후 제출하면 시험이 종료 되며 거의 즉시 결과가 이메일로 옵니다. (약 제출 후 10초 이내) 또한, 인증서는 최대 2주가 소요가 됩니다. (저의 경우 3일만에 메일로 전달 받았습니다)","link":"/2021/01/06/TensorFlow-Certificate/"},{"title":"[환경설정] Apple Silicon Table Desktop 설치","text":"현재(2021.01.07) M1 Mac에서 최신 버전(2020.4)의 Tableau Desktop 설치 시 에러가 발생하며 2020.3 버전대를 설치하면 정상적으로 이용 할 수 있습니다. 설치 시 주의 사항현재 Tableau Desktop의 가장 최신 버전은 2020.4 입니다. M1 Mac에서 2020.4 버전을 설치하려는 경우 다음과 같이 에러를 확인할 수 있습니다. 하지만 2020.3 버전의 Tableau Desktop 설치를 하면 정상적으로 설치할 수 있습니다. 다운로드2020.3 버전의 Tableau Desktop 설치를 위해서 링크를 클릭하면 과거 버전의 Tableau Desktop 설치 파일을 다운로드할 수 있는 페이지로 이동합니다. 2020.3.4버전을 선택 후 스크롤을 아래로 내려 Mac 버전의 Tableau 설치파일을 다운로드할 수 있습니다. 설치 과정2020.3 버전대의 설치 파일을 실행하면 정상적으로 설치 프로그램이 실행됩니다. 다운로드한 설치 파일을 실행 후 라이선스 동의 후 설치 과정을 계속 진행합니다. 비밀번호 또는 Touch ID 인증 후 설치 과정을 계속 진행합니다. 설치가 완료되면 Tableau Desktop 앱을 실행합니다. 만약 제품키가 없는 경우 체험판(14일) 활성화를 제품키가 있는 경우 인증 후 정상적으로 이용 할 수 있습니다.","link":"/2021/01/07/SETTING-TABLEAU-M1/"},{"title":"DATA-COVID-19-04","text":"오픈API를 이용해서 받아온 코로나 감염 현황 정보를 데이터를 시각화합니다. 만약 데이터가 없는 경우 데이터 수집이 필요합니다.데이터만 필요한 경우 다운로드를 클릭하여 데이터를 다운로드 받을 수 있습니다.가공된 데이터를 만드는 과정은 데이터 가공에서 확인 할 수 있습니다. 데이터 업로드Google Colab 환경에서 외부 데이터를 읽어오는 방법은 업로드 하는 방법과 구글 드라이브를 마운트해서 읽어오는 방법이 있습니다. 본 글에서는 직접 업로드를 통해 외부 데이터를 Colab 환경에 추가합니다. 이를 위해 좌측의 폴더 모양 아이콘을 클릭합니다. 만약 세션에 연결되어있지 않다면 자동으로 세션을 연결 합니다. 이후 좌측의 업로드 아이콘을 클릭하여 업로드 하고자 하는 파일을 선택합니다. 글꼴 설정Colab에서 한글이 포함된 데이터를 시각화 하면 정상적으로 출력이 되지 않는 문제가 존재합니다. 이를 위해 한글 폰트를 설치하고 런타임을 재시작 합니다. 1234#실행 후 런타임 -&gt; 다시 시작!sudo apt-get install -y fonts-nanum!sudo fc-cache -fv!rm ~/.cache/matplotlib -rf 업로드가 완료되면 데이터를 읽어 옵니다. 만약 에러가 발생하는 경우 파일을 선택 후 우클릭을 통해 파일 이름을 변경하고 다시 데이터를 읽으면 정상적으로 읽어옵니다. 데이터 읽어오기분석에 필요한 모듈을 설정합니다. 12345import pandas as pd import matplotlib.pyplot as plt from matplotlib import rcParamsrcParams['axes.unicode_minus'] = Falseplt.rc('font', family='NanumBarunGothic') 앞서 데이터 가공 과정 저장한 코로나 19 감염 현황 가공 완료.xlsx을 Pandas 모듈을 이용하여 DataFrame으로 불러옵니다. 12df = pd.read_excel('코로나 19 감염 현황 가공 완료.xlsx')df 인덱스 설정Series 또는 DataFrame에서 plot 함수를 이용하여 데이터를 시각화 할 수 있습니다. index가 X축, value가 Y축으로 지정되며 DataFrame의 컬럼이 여러개인 경우 한 그래프에 각 컬럼별 차트가 추가됩니다. 이를 위해 기준일 컬럼을 인덱스로 지정합니다. 12df.set_index('기준일', inplace=True)df 일별 데이터 시각화DataFrame에서 원하는 컬럼만 시각화 하고 싶은 경우 데이터 프레임을 인덱싱 후 시각화 하거나 원하는 컬럼명을 지정 할 수 있습니다. 일별 확진자 수 시각화12df.plot(y='확진자 수', figsize=(10, 5))plt.show() 전일대비 확진자 수 시각화12df.plot(y='전일대비 확진자 수', figsize=(10, 5))plt.show() 신규 확진자 수 시각화123df['신규 확진자 수'] = df['전일대비 확진자 수'].abs().fillna(0)df.plot(y='신규 확진자 수', figsize=(10, 5))plt.show() 전일대비 누적 검사 완료 수 시각화123df['전일대비 누적 검사 완료 수'] = df['누적 검사 완료 수'].diff()df.plot(y='전일대비 누적 검사 완료 수', figsize=(10, 5))plt.show() 확진자 비율 시각화검사 수 대비 확진자 수 비율을 의미 123456789import datetimeimport numpy as npdf['확진자 비율'] = df['신규 확진자 수'] / df['전일대비 누적 검사 완료 수']value = df['확진자 비율'].fillna(0).valuesdf['확진자 비율'] = np.where(np.isinf(value), 0, value)plt.figure(figsize=(10, 5))plt.bar(df['확진자 비율'].index, df['확진자 비율'].values)plt.xlim([datetime.date(2020, 2, 1), datetime.date(2020, 12, 31)])plt.show() 월별 데이터 시각화기준일 재 수정123df['기준일_월'] = df.index.monthdf['기준일_주차'] = df.index.weekdf 월별 신규 확진자 수 합계 및 평균 계산12monthly = df.groupby(['기준일_월'])['신규 확진자 수'].agg(['sum', 'mean'])monthly 월별 신규 확진자 수 시각화12345678910fig, axis_y1 = plt.subplots()axis_y2 = axis_y1.twinx()axis_y2.plot(monthly['sum'].index, monthly['sum'].values, c='red')axis_y2.set_ylabel('신규 확진자 수 합계')axis_y1.bar(monthly['mean'].index, monthly['mean'].values)axis_y1.set_ylabel('신규 확진자 수 평균')axis_y1.set_xlabel('월 (2020년)')plt.xticks(range(1, 13))plt.title('월별 신규 확진자 수')plt.show() 주차별 데이터 시각화주차별 신규 확진자 수 합계 및 평균 계산12weekly = df.groupby(['기준일_주차'])['신규 확진자 수'].agg(['sum', 'mean'])weekly 주차별 신규 확진자 수 시각화12345678910fig, axis_y1 = plt.subplots()axis_y2 = axis_y1.twinx()axis_y2.plot(weekly['sum'].index, weekly['sum'].values, c='red')axis_y2.set_ylabel('신규 확진자 수 합계')axis_y1.bar(weekly['mean'].index, weekly['mean'].values)axis_y1.set_ylabel('신규 확진자 수 평균')axis_y1.set_xlabel('주차 (2020년)')plt.xticks(range(1, 13))plt.title('주차별 신규 확진자 수')plt.show()","link":"/2021/01/09/DATA-COVID-19-04/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Pandas","slug":"Pandas","link":"/tags/Pandas/"},{"name":"COVID-19","slug":"COVID-19","link":"/tags/COVID-19/"},{"name":"Setting","slug":"Setting","link":"/tags/Setting/"},{"name":"Crawling","slug":"Crawling","link":"/tags/Crawling/"},{"name":"오픈API","slug":"오픈API","link":"/tags/%EC%98%A4%ED%94%88API/"},{"name":"Series","slug":"Series","link":"/tags/Series/"},{"name":"DataFrame","slug":"DataFrame","link":"/tags/DataFrame/"},{"name":"Apple Silicon","slug":"Apple-Silicon","link":"/tags/Apple-Silicon/"},{"name":"TensorFlow Certificate","slug":"TensorFlow-Certificate","link":"/tags/TensorFlow-Certificate/"}],"categories":[{"name":"데이터 분석","slug":"데이터-분석","link":"/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D/"},{"name":"환경 설정","slug":"환경-설정","link":"/categories/%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95/"},{"name":"코로나 19 감염 현황 분석","slug":"데이터-분석/코로나-19-감염-현황-분석","link":"/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D/%EC%BD%94%EB%A1%9C%EB%82%98-19-%EA%B0%90%EC%97%BC-%ED%98%84%ED%99%A9-%EB%B6%84%EC%84%9D/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Apple Silicon","slug":"환경-설정/Apple-Silicon","link":"/categories/%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95/Apple-Silicon/"},{"name":"Tableau","slug":"환경-설정/Tableau","link":"/categories/%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95/Tableau/"},{"name":"Pandas","slug":"Python/Pandas","link":"/categories/Python/Pandas/"},{"name":"Deep Learning","slug":"Deep-Learning","link":"/categories/Deep-Learning/"},{"name":"TensorFlow","slug":"Deep-Learning/TensorFlow","link":"/categories/Deep-Learning/TensorFlow/"}]}